Ask is now a function that returns a string.
Sprites default to (0, 0), size 100, no colour effects, etc. on load
However, they retain their settings if the green flag is clicked again
Strings have character escaping (\r, \n, \\)

Resources files contain paths to the costume and sounds files within the
project for the sprite.

A Sprite defintion represents the code for 1 sprite.
A Module definition represents an independent set of variables, constants, etc. that
can be added onto a sprite (via the Import attribute)
Modules should be independent from each other

Not case sensitive
Array indexes are 0 based
PascalCase names
No spaces in variables names (use underscore if necessary)
There is no 'this' keyword - names cannot have any conflicts

Variables have scope
Variables outside a sprite / module definition are global
Variables inside a sprite / module defintion are local
Variables inside a method are scoped only to that method
etc.

Sprites can access other sprites
Local variables can be accessed using the (var v) of (sprite v) block
Events can be raised using broadcast blocks

Consts get auto inlined
The "inline" option on a void causes the code to be placed directly inside the caller
- A custom block will not be created
- If a recursive function is found the compiler should indicate to remove the inline tag
The "atomic" option on a method causes the method to run without screen refresh

Each custom block gets an extra thread and thread start parameter
The thread indicates the list to use as the stack for all scoped variables
A new thread ID is used for each event handler
(Dynamic thread ID values by incrementing and decrementing active threads variable?)
The thread start parameter indicates the index of the first local variable in the stack
Arrays take up multiple elements in the stack and have fixed size
Lists are stored in an external, indexed heap and the index to their index is stored in
the stack
When an item is added / removed from the heap, all the indexes in the heap must be updated

Type validation is compile-time only
Each variable is given an initial type
(Method parameters natively support this anyway)
A variable can only be assigned if the type of the RHS matches the variable type
Type conversions can be done using operators
Operators will always accept objects as inputs
However, they have a fixed output type
Eg. + will always be an number, . will always give a string
Number to string:   myNum . ''
Number to boolean:  myNum == 1
String to number:   myString + 0
String to boolean:  myString == 'true'
Boolean to number:  myBool + 0
Boolean to string:  myBool . ''